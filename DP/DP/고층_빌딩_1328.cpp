//
//  고층_빌딩_1328.cpp
//  DP
//
//  Created by jiho park on 2020/03/11.
//  Copyright © 2020 jiho park. All rights reserved.
//

#include <iostream>

#define endl "\n"
using namespace std;

//나는 점화식을 만들어야하는 dp문제에 굉장히 취약한 것 같다.
//dp[n][l][r]은 n개의 빌딩이 있을 때, 왼쪽에서 보면 l개, 오른쪽에서 보면 r개가 보인다는 뜻이다.
//이 문제를 어떻게 접근하나면 dp[1][1][1]=1 먼저 빌딩하나를 놓는다. 이 빌딩은 가장 큰 빌딩이 된다.
//이 상태에서 빌딩에 하나를 추가할 때는 무조건 현재 세워져있는 빌딩보다 작을 빌딩을 놓을 것이다. 그래서 dp[1][1][1]에 놓는 빌딩이 가장 높다.
//dp[4][2][2]를 구하려고 한다.
//이제 놓을 빌딩은 가장 작아야 하기 때문에 1이라고 가정하자. 1을 어디든 놓았을 때 dp[4][2][2]되는 수를 구한다. 빌딩의 높이는 여기서 전혀 중요하지 않다. 단지 가장 낮은 빌딩을 세운다는 것을 표현하기 위해서 사용한다.
//경우의 수는 3가지. 가장 왼쪽에 놓거나, 가장 오른쪽에 놓거나, 건물들 사이에 놓거나.
//1은 가장 왼쪽에 놓을 수 있다. 예를 들면, 1423. 즉 왼쪽에서 보는 l이 1이 추가되어 3이 된다. dp[3][1][2].
//즉, dp[i-1][l-1][r]의 모양의 건물에 맨 왼쪽에 건물을 가장 작은것을 놓으면 dp[i][l][r]이 되고 따라서 dp[i-1][l-1][r]개 만큼이 포함된다.
//같은 방법으로 dp[i-1][l][r-1]도 포함된다.
//가운데는 i개의 빌딩을 구하려고 한다면 i-1개의 빌딩 사이에 가장 작은 빌딩을 세워야 하는데, i-2개의 공간이 나온다. 따라서 (i-2)*dp[i-1][l][r]이다. 가장 작은 빌딩을 빌딩 사이에만 세우기 때문에 l,r의 값은 변하지 않는다. 어차피 가려서 안보이니까.

int N,L,R;
long long dp[101][101][101];
long long MOD=1000000007;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> N >> L >> R;
    
    dp[1][1][1]=1;
    
    for(int i=2; i<=N; i++){
        for(int j=1; j<=L; j++){
            for(int k=1; k<=R; k++){
                dp[i][j][k] = (dp[i-1][j][k-1] + dp[i-1][j-1][k] +(i-2)*dp[i-1][j][k]) % MOD;
            }
        }
    }
    cout << dp[N][L][R];
    
    return 0;
}
